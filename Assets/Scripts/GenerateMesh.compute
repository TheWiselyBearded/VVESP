#pragma kernel GenerateMesh

RWStructuredBuffer<float3> vertices;
RWStructuredBuffer<float2> uvs;
RWStructuredBuffer<int> triangles;
RWStructuredBuffer<int> triangleCounter;

uint width;
uint height;
float maxEdgeLength;
float maxSurfaceAngle;

float3 CalculateNormal(float3 v1, float3 v2, float3 v3)
{
    float3 edge1 = v2 - v1;
    float3 edge2 = v3 - v1;
    return normalize(cross(edge1, edge2));
}

bool IsValidTriangle(float3 v1, float3 v2, float3 v3)
{
    // Check edge lengths
    float edge1Length = length(v2 - v1);
    float edge2Length = length(v3 - v2);
    float edge3Length = length(v1 - v3);
    
    if (edge1Length > maxEdgeLength || edge2Length > maxEdgeLength || edge3Length > maxEdgeLength)
        return false;
    
    // Check if triangle is degenerate
    float3 normal = CalculateNormal(v1, v2, v3);
    if (any(isnan(normal)) || length(normal) < 0.001f)
        return false;
        
    return true;
}

[numthreads(8,8,1)]
void GenerateMesh(uint3 id : SV_DispatchThreadID)
{
    if (id.x >= width-1 || id.y >= height-1)
        return;
    
    uint currentPixel = id.y * width + id.x;
    uint rightPixel = currentPixel + 1;
    uint bottomPixel = (id.y + 1) * width + id.x;
    uint bottomRightPixel = bottomPixel + 1;
    
    // Get vertices
    float3 v00 = vertices[currentPixel];
    float3 v10 = vertices[rightPixel];
    float3 v01 = vertices[bottomPixel];
    float3 v11 = vertices[bottomRightPixel];
    
    // Try to create triangles
    if (IsValidTriangle(v00, v01, v10))
    {
        uint triIndex;
        InterlockedAdd(triangleCounter[0], 3, triIndex);
        
        triangles[triIndex] = currentPixel;
        triangles[triIndex + 1] = bottomPixel;
        triangles[triIndex + 2] = rightPixel;
    }
    
    if (IsValidTriangle(v10, v01, v11))
    {
        uint triIndex;
        InterlockedAdd(triangleCounter[0], 3, triIndex);
        
        triangles[triIndex] = rightPixel;
        triangles[triIndex + 1] = bottomPixel;
        triangles[triIndex + 2] = bottomRightPixel;
    }
}